<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dukshot - 截圖</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
          "Noto Sans TC", sans-serif;
        cursor: crosshair;
        overflow: hidden;
        background: rgba(0, 0, 0, 0.3);
        user-select: none;
      }

      #captureCanvas {
        position: absolute;
        top: 0;
        left: 0;
        cursor: crosshair;
      }

      #maskCanvas {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        z-index: 998;
      }

      .selection-rect {
        position: absolute;
        border: 2px solid #0066ff;
        background: transparent;
        pointer-events: none;
        z-index: 1000;
      }

      .selection-info {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-family: "Consolas", monospace;
        z-index: 1001;
        pointer-events: none;
      }

      .capture-toolbar {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 8px;
        padding: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        z-index: 1002;
        display: none;
        gap: 8px;
        align-items: center;
        flex-direction: row;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }


      .capture-btn {
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.15);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .capture-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .capture-btn svg {
        transition: transform 0.2s ease;
      }

      .capture-btn:hover svg {
        transform: scale(1.1);
      }

      .help-text {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 1003;
        text-align: center;
      }

      /* 遮罩層樣式 */
      .mask-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7); /* 加深遮罩暗度 0.4 -> 0.7 */
        z-index: 999;
        display: none;
        pointer-events: none;
      }

      .mask-overlay.active {
        display: block;
      }

      /* 選取區域挖洞的洞 */
      .mask-overlay::before {
        content: '';
        position: absolute;
        background: transparent;
        border: 2px solid rgba(255, 255, 255, 0.8);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.3);
      }

      /* 格線覆層樣式 */
      .grid-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1000;
        display: none;
        pointer-events: none;
      }

      .grid-overlay.active {
        display: block;
      }

      .grid-lines {
        position: absolute;
        background: repeating-linear-gradient(
          to right,
          transparent,
          transparent 19px,
          rgba(255, 255, 255, 0.3) 20px
        );
      }

      .grid-lines.vertical {
        width: 100%;
        height: 1px;
      }

      .grid-lines.horizontal {
        width: 1px;
        height: 100%;
        background: repeating-linear-gradient(
          to bottom,
          transparent,
          transparent 19px,
          rgba(255, 255, 255, 0.3) 20px
        );
      }

      /* 座標顯示樣式 */
      .coordinate-display {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 14px;
        font-family: "Consolas", monospace;
        z-index: 1004;
        pointer-events: none;
        display: none;
      }

      .coordinate-display.active {
        display: block;
      }
      /* 尺寸標示樣式 */
      .size-indicator {
        position: absolute;
        background: rgba(0, 0, 0, 0.7);
        color: #ffffff;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 14px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans TC", sans-serif;
        z-index: 1005;
        pointer-events: none;
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="help-text">按住滑鼠左鍵並拖拽選擇截圖區域，按 ESC 取消截圖，右鍵重新抓取或再次取消</div>

    <canvas id="captureCanvas"></canvas>
    <canvas id="maskCanvas"></canvas>
    <div class="selection-rect" id="selectionRect"></div>
    <div class="selection-info" id="selectionInfo"></div>
    <!-- 尺寸標示 -->
    <div class="size-indicator" id="sizeIndicator"></div>

    <!-- 遮罩層 -->
    <div class="mask-overlay" id="maskOverlay"></div>

    <!-- 格線覆層 -->
    <div class="grid-overlay" id="gridOverlay">
      <div class="grid-lines vertical" id="verticalGrid"></div>
      <div class="grid-lines horizontal" id="horizontalGrid"></div>
    </div>

    <div class="capture-toolbar" id="captureToolbar">
      <button class="capture-btn" id="copyBtn" title="複製截圖 (Ctrl+C)">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"/>
        </svg>
      </button>
      <button class="capture-btn" id="saveBtn" title="儲存截圖 (Enter)">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" fill="currentColor"/>
        </svg>
      </button>
      <button class="capture-btn" id="uploadBtn" title="上傳截圖">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" fill="currentColor"/>
        </svg>
      </button>
      <button class="capture-btn" id="cancelBtn" title="取消 (Esc)">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" fill="currentColor"/>
        </svg>
      </button>
     <!-- 座標顯示區域 -->
    <div class="coordinate-display" id="coordinateDisplay"></div>
    </div>

    <script>
      class CaptureScreen {
        constructor() {
          console.log('CaptureScreen: 初始化開始');
          this.canvas = document.getElementById("captureCanvas");
          this.ctx = this.canvas.getContext("2d");
          // 尺寸標示元素
          this.sizeIndicator = document.getElementById("sizeIndicator");
          this.maskCanvas = document.getElementById("maskCanvas");
          this.maskCtx = this.maskCanvas.getContext("2d");
          this.isSelecting = false;
          this.startX = 0;
          this.startY = 0;
          this.currentX = 0;
          this.currentY = 0;
           this.selectedRegion = null;
           this.isDragging = false;
           this.dragOffset = { x: 0, y: 0 };
          this.selectedRegion = null;
          this.hasRecaptured = false; // 追蹤是否已經重新抓取過

          // 影像平滑策略（可切換）：預設關閉以避免文字插值模糊
          this.smoothingEnabled = false;

          // 遮罩和格線元素
          this.maskOverlay = document.getElementById("maskOverlay");
          this.gridOverlay = document.getElementById("gridOverlay");
          // 座標顯示元素
          this.coordinateDisplay = document.getElementById("coordinateDisplay");

          this.init();
        }

        async loadSettingsForCapture() {
          try {
            const settings = await window.electronAPI.settings.get();
            this.highDpiCapture = settings?.highDpiCapture !== false;
            this.smoothingEnabled = !!settings?.smoothing;
            console.log("[Capture Settings] highDpiCapture:", this.highDpiCapture, " smoothing:", this.smoothingEnabled);
          } catch (e) {
            console.warn("[Capture Settings] 載入失敗，使用預設值", e);
            this.highDpiCapture = true;
            this.smoothingEnabled = false;
          }
        }

        async init() {
          console.log('CaptureScreen: init() 開始');

          // 讀取設定
          await this.loadSettingsForCapture();
          
          // === 螢幕環境診斷 ===
          this.diagnoseDPI();
          
          // 設定畫布大小為螢幕大小（DPI 感知，可由設定控制）
          this.setupCanvasWithDPI();

          console.log('CaptureScreen: 畫布設定完成', this.canvas.width, 'x', this.canvas.height);

          // 設定事件監聽器（先設定，以便接收螢幕數據）
          this.setupEventListeners();

          // 監聽螢幕數據
          this.listenForScreenData();
        }

        // 螢幕環境診斷
        diagnoseDPI() {
          const diagnostics = {
            devicePixelRatio: window.devicePixelRatio,
            screenSize: { width: window.screen.width, height: window.screen.height },
            viewportSize: { width: window.innerWidth, height: window.innerHeight },
            colorDepth: window.screen.colorDepth,
            pixelDepth: window.screen.pixelDepth
          };
          
          console.log('=== 螢幕環境診斷 ===');
          console.log('Device Pixel Ratio:', diagnostics.devicePixelRatio);
          console.log('螢幕尺寸:', diagnostics.screenSize);
          console.log('視窗尺寸:', diagnostics.viewportSize);
          console.log('色彩深度:', diagnostics.colorDepth, 'bits');
          console.log('像素深度:', diagnostics.pixelDepth, 'bits');
          
          // 檢查是否為高 DPI 螢幕
          if (diagnostics.devicePixelRatio > 1) {
            console.log('⚠️ 檢測到高 DPI 螢幕，需要進行 DPI 適配');
          } else {
            console.log('✅ 標準 DPI 螢幕');
          }
          
          this.screenDiagnostics = diagnostics;
        }

        // DPI 感知的 Canvas 設置
        setupCanvasWithDPI() {
          const dpr = this.highDpiCapture ? (window.devicePixelRatio || 1) : 1;
          const screenWidth = window.screen.width;
          const screenHeight = window.screen.height;
          
          // 設置 Canvas 實際解析度（考慮 DPI）
          this.canvas.width = screenWidth * dpr;
          this.canvas.height = screenHeight * dpr;
          this.maskCanvas.width = screenWidth * dpr;
          this.maskCanvas.height = screenHeight * dpr;
          
          // 設置 Canvas CSS 顯示尺寸
          this.canvas.style.width = screenWidth + 'px';
          this.canvas.style.height = screenHeight + 'px';
          this.maskCanvas.style.width = screenWidth + 'px';
          this.maskCanvas.style.height = screenHeight + 'px';
          
          // 縮放 Canvas 上下文以匹配 DPI
          this.ctx.scale(dpr, dpr);
          this.maskCtx.scale(dpr, dpr);
          
          // 設置圖片渲染品質（可切換）
          this.ctx.imageSmoothingEnabled = this.smoothingEnabled;
          this.ctx.imageSmoothingQuality = this.smoothingEnabled ? 'high' : 'low';
          
          console.log('=== Canvas DPI 設置 ===');
          console.log('Device Pixel Ratio:', dpr);
          console.log('Canvas 實際尺寸:', this.canvas.width, 'x', this.canvas.height);
          console.log('Canvas CSS 尺寸:', this.canvas.style.width, this.canvas.style.height);
          console.log('圖片平滑設置:', this.ctx.imageSmoothingEnabled);
          console.log('圖片平滑品質:', this.ctx.imageSmoothingQuality);
        }

        listenForScreenData() {
          console.log('CaptureScreen: 等待螢幕數據...');
          
          // 監聽從主進程傳來的螢幕數據
          window.electronAPI.onScreenData((screenData) => {
            console.log('CaptureScreen: 接收到螢幕數據');
            this.loadScreenImage(screenData);
          });
        }
        
        loadScreenImage(screenData) {
          const img = new Image();
          img.onload = () => {
            console.log('=== 圖片載入診斷 ===');
            console.log('原始圖片尺寸:', img.naturalWidth, 'x', img.naturalHeight);
            console.log('Canvas 尺寸:', this.canvas.width, 'x', this.canvas.height);
            console.log('縮放比例:', this.canvas.width / img.naturalWidth, 'x', this.canvas.height / img.naturalHeight);
            
            // 檢查圖片與 Canvas 尺寸匹配程度
            const scaleX = this.canvas.width / img.naturalWidth;
            const scaleY = this.canvas.height / img.naturalHeight;
            if (Math.abs(scaleX - 1) > 0.01 || Math.abs(scaleY - 1) > 0.01) {
              console.log('⚠️ 圖片需要縮放，可能影響品質');
            } else {
              console.log('✅ 圖片尺寸匹配，無需縮放');
            }
            
            console.log('CaptureScreen: 繪製背景圖片');
            
            // 使用繪製方式（依 smoothingEnabled）
            this.ctx.save();
            this.ctx.imageSmoothingEnabled = this.smoothingEnabled;
            this.ctx.imageSmoothingQuality = this.smoothingEnabled ? 'high' : 'low';
            
            // 如果是高 DPI，需要調整繪製方式
            const dpr = (this.highDpiCapture ? (window.devicePixelRatio || 1) : 1);
            if (dpr > 1) {
              // 高 DPI 下的精確繪製：以 1:1 像素對齊避免插值
              this.ctx.drawImage(
                img,
                0,
                0,
                img.naturalWidth,
                img.naturalHeight,
                0,
                0,
                window.screen.width,
                window.screen.height
              );
            } else {
              // 標準 DPI 繪製
              this.ctx.drawImage(
                img,
                0,
                0,
                this.canvas.width,
                this.canvas.height
              );
            }
            
            this.ctx.restore();
            
            // 重置重新抓取狀態
            this.hasRecaptured = false;
            
            // 載入完成後立即顯示初始暗化遮罩
            this.showInitialMask();
          };
          img.onerror = (error) => {
            console.error('CaptureScreen: 載入圖片失敗', error);
          };
          img.src = screenData;
        }
        
        // 顯示初始暗化遮罩
        showInitialMask() {
          // 使用 Canvas 繪製全螢幕暗化遮罩
          this.maskCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          this.maskCtx.fillRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);
        }

        // 繪製延伸線（輔助線）
        drawExtensionLines(x, y, width, height) {
          this.maskCtx.save();

          // 設定延伸線樣式
          this.maskCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
          this.maskCtx.lineWidth = 1;
          this.maskCtx.setLineDash([5, 5]);

          // 開始繪製路徑
          this.maskCtx.beginPath();

          // 上邊延伸線：從選區上邊延伸到頂部和底部
          this.maskCtx.moveTo(x, 0);
          this.maskCtx.lineTo(x, y);
          this.maskCtx.moveTo(x + width, 0);
          this.maskCtx.lineTo(x + width, y);

          // 下邊延伸線：從選區下邊延伸到頂部和底部
          this.maskCtx.moveTo(x, y + height);
          this.maskCtx.lineTo(x, this.maskCanvas.height);
          this.maskCtx.moveTo(x + width, y + height);
          this.maskCtx.lineTo(x + width, this.maskCanvas.height);

          // 左邊延伸線：從選區左邊延伸到左右邊緣
          this.maskCtx.moveTo(0, y);
          this.maskCtx.lineTo(x, y);
          this.maskCtx.moveTo(x + width, y);
          this.maskCtx.lineTo(this.maskCanvas.width, y);

          // 右邊延伸線：從選區右邊延伸到左右邊緣
          this.maskCtx.moveTo(0, y + height);
          this.maskCtx.lineTo(x, y + height);
          this.maskCtx.moveTo(x + width, y + height);
          this.maskCtx.lineTo(this.maskCanvas.width, y + height);

          // 繪製所有延伸線
          this.maskCtx.stroke();

          this.maskCtx.restore();
       }

       // 開始拖曳
       startDragging(event) {
         this.isDragging = true;
         this.dragOffset.x = event.clientX - this.selectedRegion.x;
         this.dragOffset.y = event.clientY - this.selectedRegion.y;

         // 設置游標為 move
         document.body.style.cursor = 'move';

         // 隱藏工具列
         document.getElementById("captureToolbar").style.display = "none";
       }

       // 更新拖曳位置
       updateDragPosition(event) {
         if (!this.isDragging || !this.selectedRegion) return;

         const newX = event.clientX - this.dragOffset.x;
         const newY = event.clientY - this.dragOffset.y;

         // 邊界檢查，防止拖出螢幕
         const maxX = window.innerWidth - this.selectedRegion.width;
         const maxY = window.innerHeight - this.selectedRegion.height;
         const constrainedX = Math.max(0, Math.min(newX, maxX));
         const constrainedY = Math.max(0, Math.min(newY, maxY));

         // 更新選區位置
         this.selectedRegion.x = constrainedX;
         this.selectedRegion.y = constrainedY;

         // 更新選區視覺元素
         this.updateSelectionVisuals();
       }

       // 檢查點是否在選區內
       isInSelection(x, y) {
         if (!this.selectedRegion) return false;
         const { x: rx, y: ry, width, height } = this.selectedRegion;
         return x >= rx && x <= rx + width && y >= ry && y <= ry + height;
       }

       // 結束拖曳
       endDragging() {
         if (!this.isDragging) return;

         this.isDragging = false;
         document.body.style.cursor = 'crosshair';

         // 重新顯示工具列
         this.showToolbar();
       }

        // 更新選區視覺元素
        updateSelectionVisuals() {
          if (!this.selectedRegion) return;

          const { x, y, width, height } = this.selectedRegion;

          // 更新選區矩形
          const rect = document.getElementById("selectionRect");
          rect.style.left = x + "px";
          rect.style.top = y + "px";

          // 更新選區資訊
          const info = document.getElementById("selectionInfo");
          info.style.left = x + width + 10 + "px";
          info.style.top = y + "px";

          // 更新視覺效果
          this.updateVisualEffects(x, y, width, height);

          // 更新尺寸標示
          this.drawSizeIndicator(x, y, width, height);
        }

        onMouseMove = (event) => {
          try {
            // 更新座標顯示（無論是否在選取）
            this.updateCoordinateDisplay(event);

            // 如果正在拖曳，更新拖曳位置
            if (this.isDragging) {
              this.updateDragPosition(event);
              return;
            }

            if (!this.isSelecting) return;

            this.currentX = event.clientX;
            this.currentY = event.clientY;

            this.updateSelection();
          } catch (error) {
            console.error('CaptureScreen: onMouseMove 錯誤', error);
          }
        }

        // 繪製選區遮罩
        drawMask(x, y, width, height) {
          // 清除畫布
          this.maskCtx.clearRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);

          // 繪製全螢幕暗化遮罩
          this.maskCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          this.maskCtx.fillRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);

          // 使用 destination-out 模式完全清除選區內的遮罩（挖洞效果）
          this.maskCtx.globalCompositeOperation = 'destination-out';
          this.maskCtx.fillStyle = 'rgba(0, 0, 0, 1)'; // 使用完全不透明確保完全清除
          this.maskCtx.fillRect(x, y, width, height);

          // 重置混合模式
          this.maskCtx.globalCompositeOperation = 'source-over';

          // 繪製延伸線
          this.drawExtensionLines(x, y, width, height);
        }

        onMouseUp = (event) => {
          try {
            // 如果正在拖曳，結束拖曳
            if (this.isDragging) {
              this.endDragging();
              return;
            }

            if (!this.isSelecting) return;

            this.isSelecting = false;

            const width = Math.abs(this.currentX - this.startX);
            const height = Math.abs(this.currentY - this.startY);

            if (width > 10 && height > 10) {
              this.selectedRegion = {
                x: Math.min(this.startX, this.currentX),
                y: Math.min(this.startY, this.currentY),
                width: width,
                height: height,
              };

              this.showToolbar();
            } else {
              this.clearSelection();
            }

            // 更新座標顯示
            this.updateCoordinateDisplay(event);
          } catch (error) {
            console.error('CaptureScreen: onMouseUp 錯誤', error);
          }
        }

        onMouseDown = (event) => {
          try {
            console.log('CaptureScreen: onMouseDown', event.clientX, event.clientY);

            // 檢查是否點擊在選區內且選區已確定
            if (this.selectedRegion && this.isInSelection(event.clientX, event.clientY)) {
              this.startDragging(event);
              return;
            }

            this.isSelecting = true;
            this.startX = event.clientX;
            this.startY = event.clientY;
            this.currentX = event.clientX;
            this.currentY = event.clientY;

            // 隱藏工具列
            document.getElementById("captureToolbar").style.display = "none";
            document.querySelector(".help-text").style.display = "none";
          } catch (error) {
            console.error('CaptureScreen: onMouseDown 錯誤', error);
          }
        }

        async captureScreen() {
          try {
            console.log('CaptureScreen: 重新抓取螢幕截圖');
            
            // 重新獲取螢幕源
            const sources = await window.electronAPI.getDesktopSources();
            if (sources.length > 0) {
              this.loadScreenImage(sources[0].thumbnail);
            }
          } catch (error) {
            console.error("Error capturing screen:", error);
            alert("無法獲取螢幕截圖，請重試");
            window.close();
          }
        }

        setupEventListeners() {
          console.log('CaptureScreen: setupEventListeners 開始');
          try {
            // 檢查 Canvas 元素是否存在
            if (!this.canvas) {
              console.error('CaptureScreen: Canvas 元素不存在');
              return;
            }

            // 滑鼠事件
            this.canvas.addEventListener("mousedown", this.onMouseDown);
            this.canvas.addEventListener("mousemove", this.onMouseMove);
            this.canvas.addEventListener("mouseup", this.onMouseUp);

            // 右鍵事件
            this.canvas.addEventListener("contextmenu", this.onContextMenu);

            // 鍵盤事件
            document.addEventListener("keydown", this.onKeyDown);

            // 工具列按鈕事件
            const copyBtn = document.getElementById("copyBtn");
            const saveBtn = document.getElementById("saveBtn");
            const uploadBtn = document.getElementById("uploadBtn");
            const cancelBtn = document.getElementById("cancelBtn");

            if (copyBtn) copyBtn.addEventListener("click", this.copyToClipboard);
            if (saveBtn) saveBtn.addEventListener("click", () => this.confirmCapture("png"));
            if (uploadBtn) uploadBtn.addEventListener("click", this.uploadToDukTw);
            if (cancelBtn) cancelBtn.addEventListener("click", this.cancelCapture);

            console.log('CaptureScreen: 事件監聽器設定完成');
            console.log('CaptureScreen: setupEventListeners 結束');
          } catch (error) {
            console.error('CaptureScreen: 設定事件監聽器失敗', error);
          }
        }




        updateCoordinateDisplay(event) {
          // 只在沒有選區時顯示滑鼠座標，選區確定後隱藏座標顯示
          if (this.selectedRegion) {
            this.coordinateDisplay.classList.remove("active");
          } else {
            const x = event.clientX;
            const y = event.clientY;
            this.coordinateDisplay.textContent = `座標：${x}, ${y}`;
            this.coordinateDisplay.classList.add("active");
          }
        }

        onKeyDown = (event) => {
          if (event.key === "Escape") {
            this.cancelCapture();
          } else if (event.key === "Enter" && this.selectedRegion) {
            this.confirmCapture();
          } else if (event.key === "F6") {
            // 切換影像平滑策略，便於 A/B 測試
            this.toggleSmoothing();
          }
        }

        onContextMenu = (event) => {
          event.preventDefault(); // 防止預設右鍵選單

          if (!this.hasRecaptured) {
            // 第一次右鍵：重新抓取螢幕截圖
            this.clearSelection();
            this.captureScreen();
            this.hasRecaptured = true;
          } else {
            // 第二次右鍵：取消截圖
            this.cancelCapture();
          }
        }

        updateSelection() {
          const rect = document.getElementById("selectionRect");
          const info = document.getElementById("selectionInfo");

          const x = Math.min(this.startX, this.currentX);
          const y = Math.min(this.startY, this.currentY);
          const width = Math.abs(this.currentX - this.startX);
          const height = Math.abs(this.currentY - this.startY);

          rect.style.left = x + "px";
          rect.style.top = y + "px";
          rect.style.width = width + "px";
          rect.style.height = height + "px";
          rect.style.display = "block";

          info.textContent = `${width} × ${height}`;
          info.style.left = x + width + 10 + "px";
          info.style.top = y + "px";
          info.style.display = "block";

          // 更新視覺效果
          this.updateVisualEffects(x, y, width, height);
        }

        updateVisualEffects(x, y, width, height) {
          // 如果沒有選取區域，隱藏視覺效果
          if (width < 10 || height < 10) {
            this.hideVisualEffects();
            return;
          }

          // 顯示格線
          this.showGrid();

          // 使用 Canvas 繪製選區遮罩
          this.drawMask(x, y, width, height);

          // 更新格線位置 - 格線只在選取區域內顯示
          this.gridOverlay.style.left = x + 'px';
          this.gridOverlay.style.top = y + 'px';
          this.gridOverlay.style.width = width + 'px';
          this.gridOverlay.style.height = height + 'px';
        }

        showGrid() {
          this.gridOverlay.classList.add('active');
        }

        hideGrid() {
          this.gridOverlay.classList.remove('active');
        }

        showVisualEffects() {
          this.showGrid();
        }

        hideVisualEffects() {
          this.hideGrid();
          // 清除遮罩 Canvas
          this.maskCtx.clearRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);
          // 隱藏尺寸標示
          this.sizeIndicator.style.display = 'none';
        }

        showToolbar() {
          console.log('CaptureScreen: 顯示操作選單');
          const toolbar = document.getElementById("captureToolbar");
          const region = this.selectedRegion;

          // 計算工具列位置，確保不超出螢幕 (橫向佈局，寬度約 200px，高度約 56px)
          let left = region.x + region.width - 200;
          let top = region.y + region.height + 10;

          // 邊界檢查
          if (left < 0) left = 10;
          if (left + 200 > window.innerWidth) left = window.innerWidth - 210;
          if (top + 56 > window.innerHeight) top = region.y - 66;
          
          toolbar.style.left = left + "px";
          toolbar.style.top = top + "px";
          toolbar.style.display = "flex";
        }

        clearSelection() {
          document.getElementById("selectionRect").style.display = "none";
          document.getElementById("selectionInfo").style.display = "none";
          document.getElementById("captureToolbar").style.display = "none";
          this.selectedRegion = null;
          this.isSelecting = false;

          // 隱藏視覺效果並顯示初始遮罩
          this.hideVisualEffects();
          this.showInitialMask();
        }

        async confirmCapture(format = "png") {
          if (!this.selectedRegion) return;

          try {
            const dpr = window.devicePixelRatio || 1;

            // 創建臨時畫布來裁切選中區域（DPR 感知）
            const tempCanvas = document.createElement("canvas");
            const tempCtx = tempCanvas.getContext("2d");

            const srcX = Math.round(this.selectedRegion.x * dpr);
            const srcY = Math.round(this.selectedRegion.y * dpr);
            const srcW = Math.round(this.selectedRegion.width * dpr);
            const srcH = Math.round(this.selectedRegion.height * dpr);

            tempCanvas.width = srcW;
            tempCanvas.height = srcH;

            // 繪製設定（依 smoothingEnabled）
            tempCtx.imageSmoothingEnabled = this.smoothingEnabled;
            tempCtx.imageSmoothingQuality = this.smoothingEnabled ? "high" : "low";

            // 裁切選中區域（從高解析度 Canvas 擷取）
            tempCtx.drawImage(
              this.canvas,
              srcX,
              srcY,
              srcW,
              srcH,
              0,
              0,
              srcW,
              srcH
            );

            // 將圖片數據發送到主進程
            const mimeType = format === "jpg" ? "image/jpeg" : "image/png";
            const imageData = tempCanvas.toDataURL(mimeType);
            const result = await window.electronAPI.saveScreenshot(
              imageData,
              format
            );

            if (result.success) {
              window.close();
            } else {
              alert("儲存截圖失敗: " + (result.error || "未知錯誤"));
            }
          } catch (error) {
            console.error("Error confirming capture:", error);
            alert("截圖處理失敗: " + error.message);
          }
        }

        copyToClipboard = async () => {
          if (!this.selectedRegion) return;

          try {
            const dpr = window.devicePixelRatio || 1;

            // 創建臨時畫布來裁切選中區域（DPR 感知）
            const tempCanvas = document.createElement("canvas");
            const tempCtx = tempCanvas.getContext("2d");

            const srcX = Math.round(this.selectedRegion.x * dpr);
            const srcY = Math.round(this.selectedRegion.y * dpr);
            const srcW = Math.round(this.selectedRegion.width * dpr);
            const srcH = Math.round(this.selectedRegion.height * dpr);

            tempCanvas.width = srcW;
            tempCanvas.height = srcH;

            // 繪製設定（依 smoothingEnabled）
            tempCtx.imageSmoothingEnabled = this.smoothingEnabled;
            tempCtx.imageSmoothingQuality = this.smoothingEnabled ? "high" : "low";

            // 裁切選中區域
            tempCtx.drawImage(
              this.canvas,
              srcX,
              srcY,
              srcW,
              srcH,
              0,
              0,
              srcW,
              srcH
            );

            // 將圖片轉換為 blob
            tempCanvas.toBlob(async (blob) => {
              try {
                await navigator.clipboard.write([
                  new ClipboardItem({ [blob.type]: blob })
                ]);
                window.close();
              } catch (error) {
                console.error("Error copying to clipboard:", error);
                alert("複製到剪貼簿失敗: " + error.message);
              }
            });
          } catch (error) {
            console.error("Error processing image for clipboard:", error);
            alert("圖片處理失敗: " + error.message);
          }
        }

        uploadToDukTw() {
          // 暫時顯示開發中提示
          alert("上傳到 duk.tw 功能開發中，敬請期待！");
        }

        cancelCapture = () => {
          window.close();
        }

        // 切換影像平滑策略（F6）
        toggleSmoothing() {
          this.smoothingEnabled = !this.smoothingEnabled;
          this.ctx.imageSmoothingEnabled = this.smoothingEnabled;
          this.ctx.imageSmoothingQuality = this.smoothingEnabled ? 'high' : 'low';
          console.log(`[Smoothing] 切換為 ${this.smoothingEnabled ? '開啟' : '關閉'}`);
          // 重新繪製一次背景以反映設定（若已載入圖片）
          // 可選：觸發重新抓取或提示使用者重新開始一次截圖流程
        }
      }

      // 初始化截圖功能
      document.addEventListener("DOMContentLoaded", () => {
        new CaptureScreen();
      });
    </script>
  </body>
</html>
